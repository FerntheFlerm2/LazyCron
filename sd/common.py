#!/usr/bin/python3
# An autogenerated selection of SurpriseDog's common functions relevant to this project.
# To see how this file was created visit: https://github.com/SurpriseDog/Star-Wrangler

import os
import re
import sys
import csv
import time
import math
import queue
import shutil
import random
import socket
import threading
import subprocess
from urllib.parse import urlparse


def rint(num):
    return str(int(round(num)))


def get_volume():
    cur_level = []
    for line in srun('amixer -D pulse'):
        if 'Playback' in line and '%' in line:
            cur_level.append(int(re.split('[\\[\\]]', line)[1][:-1]))
    return int(sum(cur_level) / len(cur_level))


def set_volume(level=80):
    "Set computer master volume"
    srun("amixer -D pulse sset Master " + str(level) + "% on")


def play(filename, volume=80, player='', opts='', **kargs):
    '''Set the volume, play an audio file and then reset the volume to previous level
    Passes other args onto run'''
    current_vol = get_volume()
    set_volume(volume)

    ext = os.path.splitext(filename)[-1][1:].lower()
    if not player:
        if ext in ('ogg',):
            player = 'ogg123'
        elif ext in ('mp3',):
            player = 'mpg123'
        else:
            player = 'mpv'  # 'aplay'
    quickrun(player, opts, filename, **kargs)
    set_volume(current_vol)


def srun(*cmds, **kargs):
    "Split all text before quick run"
    return quickrun(flatten([str(item).split() for item in cmds]), **kargs)


def quote(text):
    "Wrap a string in the minimum number of quotes to be quotable"
    for q in ('"', "'", "'''"):
        if q not in text:
            break
    else:
        return repr(text)
    if "\n" in text:
        q = "'''"
    return q + text + q


def map_nested(func, array):
    "Apply a function to a nested array and return it"
    out = []
    for item in array:
        if type(item) not in (tuple, list):
            out.append(func(item))
        else:
            out.append(map_nested(func, item))
    return out


def bisect_small(lis, num):
    '''Given a sorted list, returns the index of the biggest number smaller than num
    Unlike bisect will never return an index which doesn't exist'''
    end = len(lis) - 1
    for x in range(end + 1):
        if lis[x] > num:
            return max(x - 1, 0)
    else:
        return end


def unique_filename(filename):
    "Given a filename, add a counter if needed to ensure it is unique"
    if not os.path.exists(filename):
        return filename
    filename, ext = os.path.splitext(filename)
    if not filename.endswith('.'):
        filename = filename + '.'
    extra = 1
    while os.path.exists(filename + str(extra) + ext):
        extra += 1
    return filename + str(extra) + ext


class DotDict(dict):
    '''
    Example:
    m = dotdict({'first_name': 'Eduardo'}, last_name='Pool', age=24, sports=['Soccer'])

    Modified from:
    https://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
    to set unlimited chained .variables like DotDict().tom.bob = 3
    '''

    def __init__(self, *args, **kwargs):
        super(DotDict, self).__init__(*args, **kwargs)
        for arg in args:
            if isinstance(arg, dict):
                for k, v in arg.items():
                    self[k] = v

        if kwargs:
            for k, v in kwargs.items():
                self[k] = v

    def __getattr__(self, attr):
        if attr in self:
            return self.get(attr)
        else:
            self[attr] = DotDict()
            return self[attr]

    def __setattr__(self, key, value):
        self.__setitem__(key, value)

    def __contains__(self, key):
        return bool(key in self.__dict__)

    def __setitem__(self, key, value):
        super(DotDict, self).__setitem__(key, value)
        self.__dict__.update({key: value})

    def __delattr__(self, item):
        self.__delitem__(item)

    def __delitem__(self, key):
        super(DotDict, self).__delitem__(key)
        del self.__dict__[key]


def dict_valtokey(dic, val):
    "Take a dictionary value and return the first key found:"
    for k, v in dic.items():
        if val == v:
            return k
    return None


def read_state(filename, multiline=False, forget=False, verbose=True, cleanup_age=86400):
    "todo make this a class"
    '''
    Maintains open file handles to read the state of a file without wasting resources
    forget =        open a file without maintaing open file handle
    multiline =     Return every stdout line instead of just the first.
    cleanup_age =   Minimum age to keep an old unaccessed file around before cleaning it up
    verbose =       1   Print a notification each time a new file opened
    verbose =       2   Print a notification each time a file is accesssed
    '''

    if verbose >= 2:
        print("Reading:", filename)

    # Open a file and don't add it to the log
    if forget:
        with open(filename, 'r') as f:
            if multiline:
                return list(map(str.strip, f.readlines()))
            else:
                return f.readline().strip()

    # Keep a dictionary of open files
    self = read_state
    now = time.time()
    if not hasattr(self, 'filenames'):
        self.filenames = dict()         # dictionary of filenames to file handles
        self.history = dict()           # When was the last time file was opened?
        self.last_cleanup = now         # Cleanup old files, occassionally
        # There is a limit to the number of open file handles.
        self.limit = 64                 # int(resource.getrlimit(resource.RLIMIT_NOFILE)[0] / 4)

    # Cleanup old unused file handles
    if cleanup_age and now - self.last_cleanup > cleanup_age / 2:
        self.last_cleanup = now
        for name in list(self.history.keys()):
            if name == filename:
                continue
            if now - self.history[name] > cleanup_age:
                print("Removing old file handle:", name)
                f = self.filenames[name]
                del self.filenames[name]
                del self.history[name]
                f.close()

    # Remove files if past the limit of file handles
    if len(self.filenames) > self.limit:
        earliest = sorted(list(self.history.values()))[0]
        name = dict_valtokey(self.history, earliest)
        print("\nToo many open handles! Removing:", name)
        f = self.filenames[name]
        f.close()
        del self.filenames[name]
        del self.history[name]

    # Open the file
    if filename not in self.filenames:
        if verbose:
            print("Opening", '#' + str(len(self.filenames) + 1) + ':', filename)
        try:
            f = open(filename, 'r')
        except BaseException:
            raise ValueError("Could not open: " + filename)
        self.filenames[filename] = f
    else:
        f = self.filenames[filename]
        f.seek(0)
    self.history[filename] = now

    # Return data
    if multiline:
        return list(map(str.strip, f.readlines()))
    else:
        return f.readline().strip()


def search_list(expr, the_list, getfirst=False, func='match', ignorecase=True, searcher=None):
    '''Search for expression in each item in list (or dictionary!)
    getfirst = Return the first value found, otherwise None
    searcher = Custom lamda function'''

    if not searcher:
        # func = dict(search='in').get('search', func)
        # Avoiding regex now in case substring has a regex escape character
        if ignorecase:
            expr = expr.lower()
        if func in ('in', 'search'):
            if ignorecase:
                def searcher(expr, item):         # pylint: disable=E0102
                    return expr in item.lower()
            else:
                def searcher(expr, item):         # pylint: disable=E0102
                    return expr in item
        elif func == 'match':
            if ignorecase:
                def searcher(expr, item):         # pylint: disable=E0102
                    return item.lower().startswith(expr)
            else:
                def searcher(expr, item):         # pylint: disable=E0102
                    return item.startswith(expr)
        else:
            # Could have nested these, but this is faster.
            raise ValueError("Unknown search type:", func)

    output = []
    for item in the_list:
        if searcher(expr, item):
            if isinstance(the_list, dict):
                output.append(the_list[item])
            else:
                output.append(item)
            if getfirst:
                return output[0]
    return output


def check_internet(timeout=8, tries=1):
    "Check internet connection, return True if on"
    ips = ['8.8.8.8', '8.8.4.4', '1.1.1.1']
    for tri in range(tries):
        if tri:
            time.sleep(2)
        ip = random.choice(ips)
        try:
            socket.create_connection((ip, 53), timeout)
            return True
        except OSError:
            pass
    return False


def read_csv(filename, ignore_comments=True, cleanup=True, headers=None, merge=False, delimiter=',', **kargs):
    '''Read a csv while stripping comments and turning numbers into numbers
    ignore_comments = ignore a leading #
    cleanup = remove quotes and fix numbers
    headers = instead of a list return a dict with headers as keys for columns
    delimiter = seperator between columns.
    If you provide a list it will try each one in turn, but the first option must be a single character
    merge = merge repeated delimiter'''

    def clean(row):
        "Strip all the junk off of csv file"
        if not cleanup:
            return row
        out = []
        for item in row:
            # Cleanup any quote wraps
            item = item.strip()
            if item.startswith("'") and item.endswith("'"):
                item.strip("'")
            if item.startswith('"') and item.endswith('"'):
                item.strip('"')

            # Check if its a number
            if item.lstrip('-').replace('.', '', 1).isdigit():
                if '.' in item:
                    item = float(item)
                else:
                    item = int(item)
            out.append(item)
        return out

    def get_headers(row):
        if not headers:
            return row

        out = {key: None for key in headers}
        length = len(headers)
        count = 0
        for item in row:
            if count >= length:
                if item:
                    print("Warning! Unused items while reading line:", row[count:])
                break
            out[headers[count]] = item
            count += 1
        return out

    with open(filename) as f:
        for line in f.readlines():
            if not line:
                yield get_headers(clean([]))

            if delimiter[0] in line:
                row = next(csv.reader([line], delimiter=delimiter[0], **kargs))
            else:
                for d in delimiter[1:]:
                    if d in line:
                        # This is fixed in python 3.7 anyway: https://github.com/PyCQA/pylint/issues/3424
                        row = next(csv.reader([line.replace(d, delimiter[0])], delimiter=delimiter[0],
                                   **kargs))
                        print("Using backup delimiter to read line:", repr(d))
                        break
                else:
                    continue

            if row:
                if merge:
                    # Eliminate empty columns
                    row = [item for item in row if item]
                if not ignore_comments:
                    yield get_headers(clean(row))
                elif not row[0].startswith('#'):
                    yield get_headers(clean(row))


def error(*args, header='\nError:', err=RuntimeError, **kargs):
    eprint(*args, header=header, v=3, **kargs)
    raise err


def safe_filename(filename, src="/ ", dest="-_", no_http=True, length=200,
                  forbidden='''*?\\/:<>|'"''', replacement='.'):
    '''Convert urls and the like to safe filesystem names
    src, dest is the character translation table
    length is the max length allowed, set to 200 so rdiff-backup doesn't get upset
    forbidden characters are replaced with the replacement character'''
    if no_http:
        if filename.startswith("http") or filename.startswith("www."):
            netloc = urlparse(filename).netloc
            filename = filename[filename.find(netloc):]
            filename = re.sub("^www\\.", "", filename)
            filename = filename.strip('/')
    filename = filename.translate(filename.maketrans(src, dest)).strip()
    return ''.join(c if c not in forbidden else replacement for c in filename.strip())[:length]


def joiner(char, *args):
    "Convert to string and join with character"
    if len(args) == 1 and type(args[0]) in (tuple, list):
        args = args[0]
    return char.join(map(str, args))


def mkdir(target, exist_ok=True, **kargs):
    "Make a directory without fuss"
    os.makedirs(target, exist_ok=exist_ok, **kargs)


def percent(num, digits=0):
    if not digits:
        return str(int(num * 100)) + '%'
    else:
        return sig(num * 100, digits) + '%'


def sorted_array(array, column=-1, reverse=False):
    "Return sorted 2d array line by line"
    pairs = [(line[column], index) for index, line in enumerate(array)]
    for _val, index in sorted(pairs, reverse=reverse):
        # print(index, val)
        yield array[index]


def avg(lis):
    "Average a list"
    return sum(lis) / len(lis)


def flatten(tree):
    "Flatten a nested list, tuple or dict of any depth into a flat list"
    # For big data sets use this: https://stackoverflow.com/a/45323085/11343425
    out = []
    if isinstance(tree, dict):
        for key, val in tree.items():
            if type(val) in (list, tuple, dict):
                out += flatten(val)
            else:
                out.append({key: val})

    else:
        for item in tree:
            if type(item) in (list, tuple, dict):
                out += flatten(item)
            else:
                out.append(item)
    return out


def undent(text, tab=''):
    "Remove whitespace at the beginning of lines of text"
    return '\n'.join([tab + line.lstrip() for line in text.splitlines()])


def warn(*args, header="\n\nWarning:", sep=' ', delay=1 / 64, confirm=False):
    msg = undent(sep.join(list(map(str, args))))
    time.sleep(eprint(msg, header=header, v=2) * delay)
    if confirm:
        _nul = input()


def quickrun(*cmd, check=False, encoding='utf-8', errors='replace', mode='w', stdin=None,
             verbose=0, testing=False, ofile=None, trifecta=False, hidewarning=False, **kargs):
    '''Run a command, list of commands as arguments or any combination therof and return
    the output is a list of decoded lines.
    check    = if the process exits with a non-zero exit code then quit
    testing  = Print command and don't do anything.
    ofile    = output file
    mode     = output file write mode
    trifecta = return (returncode, stdout, stderr)
    stdin    = standard input (auto converted to bytes)
    '''
    cmd = list(map(str, flatten(cmd)))
    if len(cmd) == 1:
        cmd = cmd[0]

    if testing:
        print("Not running command:", cmd)
        return []

    if verbose:
        print("Running command:", cmd)
        print("               =", ' '.join(cmd))

    if ofile:
        output = open(ofile, mode=mode)
    else:
        output = subprocess.PIPE

    if stdin:
        if type(stdin) != bytes:
            stdin = stdin.encode()

    # Run the command and get return value
    ret = subprocess.run(cmd, check=check, stdout=output, stderr=output, input=stdin, **kargs)
    code = ret.returncode
    stdout = ret.stdout.decode(encoding=encoding, errors=errors).splitlines() if ret.stdout else []
    stderr = ret.stderr.decode(encoding=encoding, errors=errors).splitlines() if ret.stderr else []

    if ofile:
        output.close()
        return []

    if trifecta:
        return code, stdout, stderr

    if code and not hidewarning:
        warn("Process returned code:", code)

    if not hidewarning:
        for line in stderr:
            print(line)

    return stdout


class Eprinter:
    '''Drop in replace to print errors if verbose level higher than setup level
    To replace every print statement type: from common import eprint as print

    eprint(v=-1)    # Normally hidden messages
    eprint(v=0)     # Default level
    eprint(v=1)     # Priority messages
    eprint(v=2)     # Warnings
    eprint(v=3)     # Errors
    '''

    # Setup: eprint = Eprinter(<verbosity level>).eprint
    # Simple setup: from common import eprint
    # Usage: eprint(messages, v=1)

    # Don't forget they must end in 'm'
    BOLD = '\033[1m'
    WARNING = '\x1b[1;33;40m'
    FAIL = '\x1b[0;31;40m'
    END = '\x1b[0m'

    def __init__(self, verbose=0):
        self.level = verbose
        self.history = []

        # If string starts with '\n', look at history to make sure previous newlines don't exist
        self.autonewlines = True

    def newlines(self, num=1):
        "Print the required number of newlines after checking history to make sure they exist."
        lines = sum([1 for line in self.history[-num:] if not line.strip()])
        num -= lines
        if num:
            print('\n' * (num), end='')
        return num


    def eprint(self, *args, v=0, color=None, header=None, **kargs):
        '''Print to stderr
        Custom color example: color='1;33;40'
        More colors: https://stackoverflow.com/a/21786287/11343425
        '''
        verbose = v
        # Will print if verbose >= level
        if verbose < self.level:
            return 0

        if not color:
            if v == 2 and not color:
                color = f"{self.WARNING}"
            if v >= 3 and not color:
                color = f"{self.FAIL}" + f"{self.BOLD}"
        else:
            color = '\x1b[' + color + 'm'

        msg = ' '.join(map(str, args))
        if self.autonewlines:
            match = re.match('^\n*', msg)
            if match:
                num = self.newlines(match.span()[1])
                if num:
                    # print('created', num, 'newlines', repr(msg[:64]))
                    msg = msg.lstrip('\n')


        self.history += msg.splitlines()
        if len(self.history) > 64:
            self.history = self.history[64:]

        if header:
            msg = header + ' ' + msg
        if color:
            print(color + msg + f"{self.END}", file=sys.stderr, **kargs)
        else:
            print(msg, file=sys.stderr, **kargs)
        return len(msg)


def list_get(lis, index, default=''):
    '''Fetch a value from a list if it exists, otherwise return default
    Now accepts negative indexes'''

    length = len(lis)
    if -length <= index < length:
        return lis[index]
    else:
        return default


def read_file(filename):
    "Read an entire file into text"
    with open(filename, 'r') as f:
        return f.read()


def read_val(file):
    "Read a number from an open file handle"
    file.seek(0)
    return int(file.read())


def trailing_avg(lis, power=0.5):
    "Weighted average that biases the last parts of this list more:"
    total = 0
    weights = 0
    for index, num in enumerate(lis):
        weight = (index + 1)**power
        total += weight * num
        weights += weight
    return total / weights


def chunker(lis, lines=2, overlap=False):
    '''Take a list a return its values n items at a time
    alternate way: zip(*[iter(lis)]*n)'''
    if len(lis) <= lines:
        yield lis
    else:
        step = 1 if overlap else lines
        for start in range(0, len(lis) - lines + 1, step):
            yield lis[start:start + lines]


def sig(num, digits=3):
    "Return number formatted for significant digits"
    num = float(num)
    if num == 0:
        return '0'
    negative = '-' if num < 0 else ''
    num = abs(num)
    power = math.log(num, 10)
    if num < 1:
        num = int(10**(-int(power) + digits) * num)
        return negative + '0.' + '0' * -int(power) + str(int(num)).rstrip('0')
    elif power < digits - 1:
        return negative + ('{0:.' + str(digits) + 'g}').format(num)
    else:
        return negative + str(int(num))


def rfs(num, mult=1000, digits=3, order=' KMGTPEZYB', suffix='B', space=' '):
    '''A "readable" file size
    mult is the value of a kilobyte in the filesystem. (1000 or 1024)
    order is the name of each level
    suffix is a trailing character (B for Bytes)
    space is the space between '3.14 M' for 3.14 Megabytes
    '''
    if abs(num) < mult:
        return sig(num) + suffix

    # https://cmte.ieee.org/futuredirections/2020/12/01/what-about-brontobytes/
    bb = mult**9
    if bb <= num < 2 * bb:
        print("Fun Fact: The DNA of all the cells of 100 Brontosauruses " + \
              "combined contains around a BrontoByte of data storage")
    if num >= bb:
        # Comment this out when BrontoBytes become mainstream
        order = list(order)
        order[9] = 'BrontoBytes'
        suffix = ''

    # Faster than using math.log:
    for x in range(len(order) - 1, -1, -1):
        magnitude = mult**x
        if abs(num) >= magnitude:
            return sig(num / magnitude, digits) + space + (order[x] + suffix).rstrip()
    return str(num) + suffix        # Never called, but needed for pylint


def spawn(func, *args, daemon=True, delay=0, **kargs):
    '''Spawn a function to run seperately and return the que
    waits for delay seconds before running
    Get the results with que.get()
    daemon = running in background, will shutdown automatically when main thread exits
    Check if the thread is still running with thread.is_alive()
    print('func=', func, id(func))'''
    # replaces fork_cmd, mcall

    def worker():
        if delay:
            time.sleep(delay)
        ret = func(*args, **kargs)
        que.put(ret)

    que = queue.Queue()
    # print('args=', args)
    thread = threading.Thread(target=worker)
    thread.daemon = daemon
    thread.start()
    return que, thread


class _TmanObj():
    "Used for ThreadManager"

    def __init__(self, func, *args, delay=0, **kargs):
        self.start = time.time()
        self.que, self.thread = spawn(func, *args, delay=delay, **kargs)

    def age(self):
        return time.time() - self.start

    def is_alive(self):
        return self.thread.is_alive()


class ThreadManager():
    "Maintain a list of threads and when they were started, query() to see if done."

    def __init__(self):
        self.threads = dict()

    def query(self, func, *args, delay=0, max_age=0, **kargs):
        "Start thread if new, return status, que.get()"
        serial = id(func)

        obj = self.threads.get(serial, None)
        if max_age and obj and obj.age() > max_age:
            print("Thread aged out")
            del obj
            obj = None
        if obj and obj.is_alive():
            print("Can't get results now, we got quilting to do!")
            return False, None
        if obj:
            del self.threads[serial]
            return True, obj.que.get()

        # print("Starting thread!")
        obj = _TmanObj(func, *args, delay=delay, **kargs)
        self.threads[serial] = obj
        return False, None

    def remove(self, func):
        "Remove thread if in dict"
        serial = id(func)
        if serial in self.threads:
            del self.threads[serial]


def check_install(*programs, msg='', quitonerr=True):
    '''Check if program is installed (and reccomend procedure to install)
    programs is the list of programs to test
    prints msg if it can't find any and returns False'''

    errors = 0
    for program in programs:
        paths = shutil.which(program)
        if not paths:
            errors += 1
            print('\n', program, 'is not installed.')
    if errors:
        if msg:
            if type(msg) == str:
                print("To install type:", msg)
            else:
                print("To install type:")
                for m in msg:
                    print('\t' + m)
        else:
            print("Please install to continue...")
        if quitonerr:
            sys.exit(1)
        return False
    return True


def gohome():
    os.chdir(os.path.dirname(sys.argv[0]))


def itercount(start=0, step=1):
    "Save an import itertools"
    x = start
    while True:
        yield x
        x += step


tman = ThreadManager()  # pylint: disable=C0103
qrun = quickrun     # pylint: disable=C0103

'''
&&&&%%%%%&@@@@&&&%%%%##%%%#%%&@@&&&&%%%%%%/%&&%%%%%%%%%%%&&&%%%%%&&&@@@@&%%%%%%%
%%%%%%%%&@&(((((#%%&%%%%%%%%%&@@&&&&&&%%%&&&&&%%%%%%%%%%%&&&&%&%#((((/#@@%%%%%%%
&&%%%%%%&@(*,,,,,,,/%&%%%%%%%&@@&&&&&%%&&&&%%&&%%%%%%%%%%&&&%#*,,,,,,*/&@&%%%%%%
%%%%%%%&@&/*,,,*,*,,*/%&%%%%%&@@&&&&&&%%&&&&&&&%%%%%%&%%%&&%*,,,,,,,,**#@&&%%%%%
&&&&&%%&@#(**********,*(#&%%%&@&&&&%%%%%%%%%&&&%%%%%%&%&&#*****,*******#@&&%%%%%
&&&%%%&&#/***/*****/*,**,*%&%&@@&&&&&&&&&&&&&&&%%%%%%&&#*,,,*/******/***(%&%%%%%
&&&%%%&%/*****///////**,,,,*/%%&&@@@@@@@@@@@@@@@@&&%#*,,,*,*(///////*****#%&%%%%
@@&%%#&#/,,,*/(//((((//**,,*/#&@@@@@&&&&&&&&&&@@@@@%(/*,,**/(/(((/(//*,,*(&&%%%%
&&&%##&#*,,,*////((((/*///(&@&@@&&&#%((//(/###%&@&@@@@#//**//(#(///***,.,/&&%%%%
%%%%%#%#*,,,**////(///((#&&&%@&%%(/*,,......,,/(#%&&&@@@%((/(/#(///**,,,,(&%%%%%
&&%%%#%%/,..***//(#(#%%&@@@&@%(*.,,..       ...,.,/#@&@@@&&%#(((///**,..,#%%%%%%
%&%%%%%#*,****/(##&@@@&@@@@&%*,....           ....,,(&@@@@@@&@&%((//****,(%%%%%%
%&%%%%%#/,**/#&@@@&@@@@@@@&(*,......    .     ..,..,.(&@@@@@@@&@@@&%#**,*(%%%%%%
&&%%%%#&#(#&@@@&@@@@@@@@%((#@@%&&((,,,,,..,,(**(%@@&@%##(&@@@@@@@@&&@@%#(%%%%%%%
&&&%%%%%&&&&&&@@@@@@%###%@(,%&/@@&(%(/*,..,*/%##&&,%@(*&@#((%&@@@@@@&&@&%%%%&&%%
&&%%%%%%&&&@@@@@@@@#((*#@%,#%%&@#%(/**//,****/(#%%%&&%*(@@*/#(&@@@@@@@&&%%%%%%%%
&&&%%%%%&@@@@&%#/,,,,*,(/%&@@&((%(*,*,,*,**,,*,*#%(#@@&%((**,,,,*#(%&@@&&%%%%%%%
&&&%%%%%@@@@%*/*,...,*,,/*#(//#****,***********,**/#/##(/*,*,...,*/*/&@@&%%&%%%%
&&%%%%%%&@@@(//,....,,*/****/,,/**************/***/,,//**/**,....,*//&@@&%%&%%%%
&&&%%%%%&@@%(/*,. ...,****/*/(//*%&@@&%%%%%%&&&&//*/(*/**/**......,/*#&@&%&&&&%%
&&%%%%%%&@@%(**,,....,/**/((/,#&&&&&%#((((((%&&&@&%/*/(/**/*,. ..,,*/((#@&&&&&&%
%&%%%%%%&&#(/**,..,,,***/((,./%&%&&&@&(/#((#@@&&&%&%,,/((*,/*,,..,,,///(%&%&&&&&
&&%%%%%%&#,**,.,..,,*(//(/,,.,&&&@#&@@##%(#&@&%%@&&#.,,/(((//*,,..,,**,*&%&&%&&&
&&%##%%%#/**,,,,..,*/((((*...,,#&##%(#%%&%%###%(%&/,.. **((((/,...,,,,**(%%#%%%&
&&%####(**,,,.,,.,,/(/(//*,,..../%&(##%&&&%%(#%&#, .. .**//(/(*,,..,.,,**/((#%%%
&&&%#///*,........,/(((//**,.   ,,(#%%%%%%&#%##**.   ,,*//((((*,........,*//(%%%
%%%%(/**...       .,/(((///*., .,*(#(%%%%%%%%##/*,..,,*///((/*.      .....**/(%%
%%%%#(,..          .,/((/(//****,/(((###%#%(#///**,,**/((/((*,          .,.,(%%%
&&%%%#/*...          ,*/(/(/((%%&#&#(/%./.*%(#%#%#&&(((/(/*,.          ..,**(&%%
&&%%%%(*.....          ..*((/**(#&&&&&&&%%%&%&&&%(/,*/((*..           .,..*(&&%%
&&%%%%&#*.      .        */(#/*,,*/((%#%%%%%((**,.*/(#(/,       .       ,(%&%%&%
%%%%%%&%#//**,..           .**(((*,...,,**,,..*,/((/*,.          ...,,//(#%%%%%%
%%%&&&%(/*,**,..,,.,..       .,,**//**,*,,,*,////*,,.        .,.,...,,,**//#%&%%
%%%&&%#/*,*,.    ...      ..         ...  ,.. .       .       ...   ..,,*/(#%&%%
&&&&&%(((*.*... . .*,.   .           .*%%#(,.          .    .*,. ..,.,,**/(%#&%%

Generated by https://github.com/SurpriseDog/Star-Wrangler
a Python tool for picking only the required code from source files
written by SurpriseDog at: https://github.com/SurpriseDog
2022-05-25
'''
